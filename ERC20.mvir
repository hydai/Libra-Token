modules:

module TokenCapability {
    // We can simulate a global variable via a singleton resource.
    // Reference: https://community.libra.org/t/any-notion-of-global-variables/355/2

    resource T {}

    // Grant Token Capability to the owner
    public grant() {
        let sender: address;
        let owner: address;
        let t: R#Self.T;

        sender = get_txn_sender();

        // We have to hardcode the owner address here,
        // because Move IR hasn't supported a syntactic sugar for retrieving the address of
        // module publisher. (e.g. Self.get_module_publisher())
        owner = ${TokenAddress};
        // 77 is just a magic number for representing a sender is not the owner.
        assert(move(sender) == move(owner), 77);

        t = T{};
        // Owner can get the Token capability.
        move_to_sender<T>(move(t));

        return;
    }

    // Return an immutable reference to the TokenCapability of the sender if
    // it exists. This will only succeed if the transaction sender is the owner.
    public borrow_sender_capability(): &R#Self.T {
        let sender: address;
        let t_ref: &R#Self.T;

        sender = get_txn_sender();
        t_ref = borrow_global<T>(move(sender));

        return move(t_ref);
    }
}

module Token {


    import Transaction.TokenCapability;

    // Token resource, representing the total balance of an accuont.
    resource T {
        value: u64,
    }

    // Create a new Token.T with a value of 0
    public zero(): R#Self.T {
        return T{value: 0};
    }

    // Return the value of a Token
    public value(token_ref: &R#Self.T): u64 {
        return *&move(token_ref).value;
    }

    // Publish an initial 0 balance Token for the sender
    public publish() {
        move_to_sender<T>(Self.zero());
    }

    // `mint_to_address` will only be called by the owner.
    // This mints a new Token worth `amount` to the payee.
    public mint_to_address(payee: address, amount: u64) {
        let capability_ref: &R#TokenCapability.T;
        let mint_token: R#Self.T;

        // Mint the coin
        capability_ref = TokenCapability.borrow_sender_capability();
        mint_token = Self.mint(copy(amount), move(capability_ref));

        // Deposit the minted `coin`
        Self.deposit(move(payee), move(mint_token));
        return;
    }

    // Mint a new Token worth `value`.
    mint(value: u64, capability: &R#TokenCapability.T): R#Self.T {
        release(move(capability));
        return T{value: move(value)};
    }

    // Return the Token balance of the transaction sender.
    public balance(): u64 {
        return move(Self.balanceOf(get_txn_sender()));
    }

    // Return the Token balance of `account`.
    public balanceOf(account: address): u64 {
        let token_ref: &mut R#Self.T;
        token_ref = borrow_global<T>(move(account));

        return move(Self.value(token_ref));
    }

    // Deposits the `to_deposit` token into the `payee`'s account
    public deposit(payee: address, to_deposit: R#Self.T) {
        let deposit_value: u64;
        let payee_token_ref: &mut R#Self.T;
        let payee_token_value: u64;

        // Check that the `to_deposit` token is non-zero
        deposit_value = Self.value(&to_deposit);
        assert(copy(deposit_value) > 0, 7);

        payee_token_ref = borrow_global<T>(move(payee));
        payee_token_value = Self.value(payee_token_ref);

        *(&mut move(payee_token_ref).value) = move(payee_token_value) + move(deposit_value);
        return;
    }

    public withdraw_from_sender(amount: u64): R#Self.T {
        let sender: address;
        let to_withdraw: R#Self.T;

        sender = get_txn_sender();
        to_withdraw = borrow_global<T>(move(sender));

        // Withdraw the token from the sender.
        to_withdraw = Self.withdraw(move(to_withdraw), move(amount));
        return move(to_withdraw);
    }

    public withdraw(to_withdraw: &mut R#Self.T, amount: u64): R#Self.T {
        let value: u64;

        value = *(&mut copy(to_withdraw).value);
        assert(copy(value) >= copy(amount), 10);

        *(&mut move(to_withdraw).value) = move(value) - copy(amount);
        return T{value: move(amount)};
    }

    // Transfer the token from the sender to the payee.
    public transfer(payee: address, amount: u64) {
         let sender_token_ref: R#Self.T;

         sender_token_ref = Self.withdraw_from_sender(move(amount));
         Self.deposit(move(payee), move(sender_token_ref));
         return;
    }
}

script:

import Transaction.TokenCapability;
import Transaction.Token;

main() {
    let sender: address;
    let capability: &R#TokenCapability.T;

    sender = get_txn_sender();

    // Grant owner's capability
    TokenCapability.grant();

    // Publish an Token account
    Token.publish();
    // Mint 1314 tokens to the owner
    Token.mint_to_address(sender, 1314);
    // Check balance == 1314
    let balance: u64;
    balance = Token.balanceOf(sender);
    assert(balance == 1314, 2);
    assert(Token.balance() == balance, 1);
    return;
}
