modules:

module TokenCapability {
    // We can simulate a global variable via a singleton resource.
    // Reference: https://community.libra.org/t/any-notion-of-global-variables/355/2

    resource T {}

    // Grant Token Capability to the owner
    public grant() {
        let sender: address;
        let owner: address;
        let t: R#Self.T;

        sender = get_txn_sender();

        // We have to hardcode the owner address here,
        // because Move IR hasn't supported a syntactic sugar for retrieving the address of
        // module publisher. (e.g. Self.get_module_publisher())
        //owner = ${TokenAddress};
        // 77 is just a magic number for representing a sender is not the owner.
        //assert(move(sender) == move(owner), 77);

        t = T{};
        // Owner can get the Token capability.
        move_to_sender<T>(move(t));
        return;
    }

    // Return an immutable reference to the TokenCapability of the sender if
    // it exists. This will only succeed if the transaction sender is the owner.
    public borrow_sender_capability(): &mut R#Self.T {
        let sender: address;
        let t_ref: &mut R#Self.T;

        sender = get_txn_sender();
        t_ref = borrow_global<T>(move(sender));

        return move(t_ref);
    }
}

module Token {

    import Transaction.TokenCapability;

    // Token resource, representing the total balance of an accuont.
    resource T {
        value: u64,
    }

    // Create a new Token.T with a value of 0
    public zero(): R#Self.T {
        return T{value: 0};
    }

    // Return the value of a Token
    public value(token_ref: &R#Self.T): u64 {
        return *&move(token_ref).value;
    }

    // Publish an initial 0 balance Token for the sender
    public publish() {
        let t: R#Self.T;
        t = Self.zero();
        move_to_sender<T>(move(t));
        return;
    }

    // `mint_to_address` will only be called by the owner.
    // This mints a new Token worth `amount` to the payee.
    public mint_to_address(payee: address, amount: u64) {
        let capability_ref: &mut R#TokenCapability.T;
        let mint_token: R#Self.T;

        // Mint the coin
        capability_ref = TokenCapability.borrow_sender_capability();
        mint_token = Self.mint(copy(amount), move(capability_ref));

        // Deposit the minted `coin`
        Self.deposit(move(payee), move(mint_token));
        return;
    }

    // Mint a new Token worth `value`.
    mint(value: u64, capability: &mut R#TokenCapability.T): R#Self.T {
        release(move(capability));
        return T{value: move(value)};
    }

    // Return the Token balance of `account`.
    public balanceOf(account: address): u64 {
        let token_ref: &mut R#Self.T;
        let token_const_ref: &R#Self.T;
        let token_val: u64;
        token_ref = borrow_global<T>(move(account));
        token_const_ref = freeze(move(token_ref));
        token_val = Self.value(move(token_const_ref));
        return move(token_val);
    }

    // Return the Token balance of the transaction sender.
    public balance(): u64 {
        let sender: address;
        let balance_val: u64;
        sender = get_txn_sender();
        balance_val = Self.balanceOf(move(sender));
        return move(balance_val);
    }

    // Deposits the `to_deposit` token into the `payee`'s account
    public deposit(payee: address, to_deposit: R#Self.T) {
        let deposit_value: u64;
        let payee_token_ref: &mut R#Self.T;
        let payee_token_const_ref: &R#Self.T;
        let payee_token_value: u64;

        // Check that the `to_deposit` token is non-zero
        T{ value: deposit_value } = move(to_deposit);
        assert(copy(deposit_value) > 0, 7);

        payee_token_ref = borrow_global<T>(move(payee));
        payee_token_const_ref = freeze(copy(payee_token_ref));
        payee_token_value = Self.value(move(payee_token_const_ref));

        *(&mut move(payee_token_ref).value) = move(payee_token_value) + move(deposit_value);
        return;
    }

    public withdraw(to_withdraw: &mut R#Self.T, amount: u64): R#Self.T {
        let value: u64;

        value = *(&mut copy(to_withdraw).value);
        assert(copy(value) >= copy(amount), 10);

        *(&mut move(to_withdraw).value) = move(value) - copy(amount);
        return T{value: move(amount)};
    }

    // Transfer the token from the sender to the payee.
    public transfer(payee: address, amount: u64) {
        let to_pay: &mut R#Self.T;
        let sender: address;
        let to_withdraw: R#Self.T;

        sender = get_txn_sender();
        to_pay = borrow_global<T>(move(sender));

        // Withdraw the token from the sender.
        to_withdraw = Self.withdraw(move(to_pay), move(amount));
        Self.deposit(move(payee), move(to_withdraw));
        return;
    }
}

script:

import Transaction.TokenCapability;
import Transaction.Token;

main() {
    let sender: address;
    let capability: &R#TokenCapability.T;
    let balance_val: u64;
    let sender_balance_val: u64;

    sender = get_txn_sender();

    // Grant owner's capability
    TokenCapability.grant();

    // Publish an Token account
    Token.publish();
    // Mint 1314 tokens to the owner
    Token.mint_to_address(copy(sender), 1314);
    // Check balance == 1314
    balance_val = Token.balanceOf(copy(sender));
    assert(copy(balance_val) == 1314, 2);
    sender_balance_val = Token.balance();
    assert(move(sender_balance_val) == move(balance_val), 1);
    return;
}
